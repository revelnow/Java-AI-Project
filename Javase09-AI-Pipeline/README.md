# 🚀 模块：AI 数据管道 (AI Data Pipeline)

## 📌 核心逻辑：为什么需要这个模块？
单纯的 AI 调用在工业场景下是脆弱的。本项目通过 Java 核心技术栈，为 AI 构建了一套具有“防御性、稳定性、节约性”的数据通道。

## 🛠️ 技术栈复盘 (Engineering Highlights)

### 1. 故障自愈：RetryUtils
- **核心算法**：指数退避 (Exponential Backoff)，设置 `MAX_DELAY` 防止僵尸线程。
- **并发控制**：响应 `InterruptedException` 并恢复中断位，确保管道在极端情况下的**优雅停机**能力。

### 2. 成本控制：ChatContextManager
- **数据结构**：`LinkedList`（双向链表），实现 $O(1)$ 复杂度的**滑动窗口算法**。
- **线程安全**：`ReentrantLock` 配合 `try-finally` 结构，确保高并发对话下的原子性与活跃性。

### 3. 海量处理：Stream Cleaner
- **内存优化**：利用 `Files.lines()` 的 **Lazy Evaluation (惰性求值)** 特性，实现 10GB 级语料库的流式清洗，空间复杂度 $O(1)$，彻底规避 OOM。
- **清洗管道**：`Map(标准化) -> Filter(防空) -> Distinct(去重)`。

## 🛡️ 深度审计记录 (Audit Log)
> 记录我在开发过程中踩过的坑与思考：
- **资源隔离**：在 `forEach` 内部使用 `try-catch` 捕获异常，防止“单行数据有毒”导致整个语料管道崩溃。
- **资源释放**：强制使用 `try-with-resources` 管理文件句柄，防止在大文件读取中途出错导致的资源泄露。

## 🎙️ 面试高频关注点 (Interview Questions)
| 考点方向 | 核心回答点 (Key Points) |
|---|---|
| 指数退避算法 | 通过逐步增加重试间隔，减少对系统的瞬时压力，提升整体稳定性。 |
| 滑动窗口原理 | 使用双向链表实现高效的元素添加与删除，适用于对话上下文管理。 |
| 惰性求值优势 | 延迟数据处理，降低内存占用，适合大规模数据流处理。 |
| 线程安全机制 | 使用显式锁（如 ReentrantLock）确保多线程环境下的数据一致性。 |  


## 🧠 防遗忘附录 (Self-Reflection) - 2026-01-09

本附录用于记录开发过程中的关键思考，便于未来快速回顾。

---

### 我当时在做什么？

- **核心任务：**构建 `Javase09-AI-Pipeline`（集成重试、滑动窗口与流式清洗的 AI 数据管道）。
- **主要目的：**解决 AI 业务中常见的：
  - 接口不稳定（网络波动）
  - 语料文件超大（内存溢出）
  - 对话上下文冗余（Token 浪费）

---

### 不这样做会出现什么？

- **内存溢出 (OOM)：**处理 10GB 级大文件时，若一次性加载会直接撑爆 JVM 内存。
- **系统死锁：**在维护 AI 记忆时，若异常处理不当导致锁无法释放，整个会话系统将卡死。
- **雪崩与封号：**对故障接口进行盲目且高频的重试，会触发厂商限流导致封号，或加剧服务器崩溃。

---

### 我一开始哪里想错了？

- **预想：**认为读取文件只需用 `Files.readAllLines()`，简单直接。  
  **实际：**在大文件场景下这是“内存杀手”。必须改用 `Files.lines()` 开启 **Lazy Evaluation（惰性求值）** 模式，实现“读一行、洗一行、发一行”，将空间复杂度从 $O(n)$ 降至 $O(1)$。

- **预想：**认为 `Thread.sleep()` 只是为了等待，捕获异常后不处理也没关系。  
  **实际：**忽略了 **中断信号 (Interruption)** 的传递。必须执行 `Thread.currentThread().interrupt()` 恢复中断位，否则上层线程池无法感知停机指令，导致程序无法“优雅停机”。

- **预想：**认为清洗数据应先“去重”再“去空格转换”。  
  **实际：**由于 `"Java "` 和 `"Java"` 在去空格前不相等，先去重会导致重复保留。  
  **严谨顺序必须是：**`Map(转换/去空) -> Filter(过滤) -> Distinct(去重)`。

---

### 关键代码锚点

看到这行代码就能想起核心逻辑：

```java
// 1. 火警恢复逻辑：惊醒后重新贴上“下班信号”，确保线程池能感知并回收资源
Thread.currentThread().interrupt(); 

// 2. 指数退避天花板：保护上游服务器，防止重试等待时间无限翻倍导致线程挂起
currentDelay = Math.min(currentDelay * 2, MAX_DELAY); 

// 3. 安全阀逻辑：无论业务逻辑是否报错，必须在 finally 块释放锁，防止系统死锁
finally { 
    lock.unlock(); 
}
````



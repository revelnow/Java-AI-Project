# 📅 2026.01.06：Java IO 安全审计与 AI 知识库工程化

## 🎯 今日目标
- [x] 掌握路径穿越（Path Traversal）的原理与防御
- [x] 熟悉 Java NIO (`Path`, `Files`) 的现代工程用法
- [x] 理解 AI 知识库中的重叠切片（Overlapping Chunking）逻辑
- [x] 实践“10%-20%-70%”人机协作与深度审计流程

---

## 📦 涉及的核心 API

### 现代 NIO 体系
- `Path`：路径坐标（支持 `normalize`, `resolve`, `toRealPath`）
- `Paths / Path.of`：路径工厂
- `Files`：文件操作工具类（`exists`, `isSymbolicLink`, `read`）

### 字符处理流
- `FileInputStream`：基础字节读取
- `InputStreamReader`：字节转字符（指定 UTF-8 编码的关键）
- `BufferedReader`：高效缓冲字符流，支持按行读取

---

## 💡 核心工程理解

## 一、文件安全：构建“路径隔离区”

### 1️⃣ 路径穿越风险
- 攻击者通过输入 `..` 试图跳出指定目录，访问系统敏感文件。
- 示例：输入 `../../etc/passwd` 绕过业务逻辑。

### 2️⃣ 黄金防御组合（防御性编程）
- **`normalize()`**：消除路径中的冗余 `..` 和 `.`。
- **`toRealPath()`**：关键一步！识别并解析符号链接（快捷方式），还原真实物理路径。
- **`startsWith()`**：最终校验，验证规范化后的真实路径是否依然在预设的“隔离区”内。



---

## 二、AI 知识库：重叠切片工程

### 3️⃣ 乱码防御：字符优先原则
- **逻辑**：字节流（`byte[]`）在读取中文时可能从汉字中间切断，导致乱码和 AI “语义幻觉”。
- **方案**：必须先转换为字符流（`char[]`），确保每一个单位都是完整字符。

### 4️⃣ 滑动窗口（Sliding Window）
- 为了解决切片导致的上下文断裂，在相邻片段间保留一部分重复内容。
- **计算公式**：$每次新读入长度 = 总切片长度 - 重叠长度$。
- **接力机制**：将当前块末尾的 `overlapSize` 字符存入变量，拼接到下一块开头。

---

## 🛠️ 关键代码锚点

### 安全审计逻辑
- `utils/FileUtils.java`：封装 `validateFileName`，检查非法字符。
- `SafeAiReader.java`：实现 `toRealPath()` 与 `startsWith()` 的双重安全校验。

### 读写与切片
- 字符缓冲流：`new BufferedReader(new InputStreamReader(...))`。
- 滑动窗口实现：利用 `substring` 维护 `overlapContent` 变量。

---

## 🎙️ 面试高频关注点
- 什么是路径穿越？如何利用 Java NIO 彻底防御？
- `toRealPath()` 和 `toAbsolutePath()` 的本质区别是什么？（提示：符号链接解析）
- 为什么处理 AI 文本时不建议直接用 `RandomAccessFile`？（提示：编码截断风险）
- 生产环境下如何处理 IO 异常？（提示：对内详尽日志，对外模糊提示）

---

## 🧠 防遗忘附录（IO Security & AI）

### 一开始我哪里容易想错？
- 以为只要检查 `..` 字符串就足够安全，忽略了符号链接（Symlink）伪装。
- 以为实现重叠切片必须频繁操作文件指针，其实在内存里做“接力”更高效且不乱码。

### 我最后记住的 5 句话
- 路径安全三部曲：规范化、真路径、前缀匹配。
- 异常处理原则：对外抛出要模糊，对内记录要详细。
- 读中文知识库，永远先指定 `UTF-8` 转字符流。
- 切片缓冲区大小公式：$chunkSize - overlapSize$。
- 严禁在生产环境代码中直接使用 `e.printStackTrace()`。

---

### 如果以后全忘了
👉 记住一句话：  
**“先还原真实路径再检查边界以保安全；先转字符流再做接力切片以保语义。”**
# 📅 2026.01.04：File 与递归遍历（为工程与 AI 输入做准备）

## 🎯 今日目标
- [x] 理解 `File` 在 Java 中的真实职责（路径 / 文件元信息）
- [x] 掌握文件与目录的区分与常用 API
- [x] 通过递归实现目录的深度遍历
- [x] 为后续「本地文件 → AI 知识输入」打基础

---

## 💡 核心工程洞察（Technical Insight）

### 1️⃣ File 在工程中的真实角色
- `File` **不负责读写内容**
- 它只承担：
    - 路径的抽象
    - 文件 / 目录元信息的描述
- 真正的读写必须交给 **IO / NIO**

👉 这是初学阶段最容易混淆、但在工程中极其关键的一点。

---

### 2️⃣ 为什么 File 经常与递归一起使用？
- 目录结构本质上是 **树结构**
- 树结构的遍历，天然适合 **递归**
- 常见工程场景：
    - 扫描日志目录
    - 加载配置文件
    - 构建本地知识库（AI 场景）

---

### 3️⃣ 写递归，关键不是“会写”，而是“不写错”
递归代码必须想清楚三件事：
1. 当前这一层要做什么
2. 什么时候继续递归
3. 什么时候必须停止（出口）

出口条件错误，会直接导致 **死递归 / 栈溢出**。

---

## 🛠️ 关键代码示例（递归遍历目录）

```java
public static void printAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }

    if (dir.isFile()) {
        System.out.println(dir.getAbsolutePath());
        return;
    }

    File[] files = dir.listFiles();
    if (files != null) {
        for (File file : files) {
            printAllFiles(file);
        }
    }
}
```
## 🎙️ 面试高频考点

### 1️⃣ File 的职责是什么？
- `File` 只负责 **文件和路径的抽象**
- 它描述的是：
    - 文件是否存在
    - 是文件还是目录
    - 路径信息、大小、权限等元数据
- **不负责任何内容读写**

👉 真正的读写必须交给 IO / NIO。

---

### 2️⃣ 为什么工程中 File 常和递归一起使用？
- 目录结构在逻辑上是 **树结构**
- 树结构的遍历天然适合用 **递归**
- 工程常见使用场景：
    - 日志目录扫描
    - 配置文件加载
    - 本地知识库文件收集（AI 场景）

---

### 3️⃣ 写递归时最容易出什么问题？
- **没有明确终止条件**
- 忘记区分「文件」和「目录」
- 递归层级过深，导致 **栈溢出**

👉 在工程中，递归的第一要义是 **安全退出**。

---

### 4️⃣ `listFiles()` 有什么坑？
- 可能返回 `null`
    - 没有访问权限
    - IO 异常
- 工程代码中必须做 **空判断**
- 不能默认它一定有返回值

---

### 5️⃣ File 在真实工程中的位置
- File 通常是：
    - 数据入口
    - 资源扫描器
- 常见搭配：
    - File + IO（读取内容）
    - File + Exception（兜底异常）
    - File + 递归（目录遍历）

---

## 🧠 防遗忘附录

### 我当时在干什么？
- 学 File 的基本使用
- 写了文件 / 目录判断
- 用递归遍历目录结构

### 一开始我哪里想错了？
- 以为 File 可以直接读写文件内容
- 写递归时没第一时间想清楚终止条件

### 我最后记住的 3 句话
- File ≠ IO
- 目录结构 = 树结构
- 写递归，先写出口

### 关键代码锚点
- File 基础判断：`FileDemo1.java`
- 文件测试：`FileTest.java`
- 递归遍历目录：`RecursionDemo3.java`

### 如果以后全忘了
👉 先看递归 Demo，再回头看 File API
